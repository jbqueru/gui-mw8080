; Copyright 2023 Jean-Baptiste "JBQ" "Djaybee" Queru
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
; 
; http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.



; 80 columns, hard 8-character tabs



; ##############################################################################
; ##############################################################################
; ###                                                                        ###
; ###                                                                        ###
; ###                                 Invadows                               ###
; ###                                                                        ###
; ###    A windowing system running on Williams 8080 hardware, as used in    ###
; ###         Gun Fight, Space Invaders, and quite a few other games.        ###
; ###                                                                        ###
; ###                                                                        ###
; ##############################################################################
; ##############################################################################



; ####################################
; ####################################
; ###                              ###
; ###                              ###
; ###     HARDWARE ENVIRONMENT     ###
; ###                              ###
; ###                              ###
; ####################################
; ####################################

; This software is designed on the hardware board that was built by
; Midway for games from Gun Fight (1975) to Space Invaders II (1980).
;
; 8080 processor, starting execution at address $0000.
; 8kB of ROM from $0000 to $1FFF
; 8kB of RAM from $2000 to $3FFF
;     including 7kB framebuffer starting at $2400, 256x224 1-bit.
;     Rotated 90 degrees CCW seen from viewer.
;     MSB to the "right" (top after rotation) (counter-intuitive!!!)
;
; I/O ports for Space Invaders (including cocktail version)
;
; Inputs
;
; port 1 input
;   0 - coin, debounced? (returns 1 once per coin, resets after read)
;   1 - 2P start
;   2 - 1P start
;   4 - 1P fire
;   5 - 1P left
;   6 - 1P right
;
; port 2 input
;   0,1 - DIP switches (number of ships from 3 to 6)
;   2 - DIP switch (0=hard, 1=easy)
;   4 - 2P fire
;   5 - 2P left
;   6 - 2P right
;   7 - DIP switch (show/hide coin info)
;
; Sounds
;
; port 3 output
;   0 - saucer (doesn't automatically stop)
;   1 - shot
;   2 - player hit
;   3 - invader hit
;   4 - extended play
;
; port 4 output
;   0 - invader motion A
;   1 - invader motion B
;   2 - invader motion C
;   3 - invader motion D
;   4 - saucer hit
;   5 - amplifier on/off
;
; Shifter
;
; port 2 output: number of bits to shift
; port 4 output: data stream
; port 3 input: data stream from port 4 shifted by number of bits
;               specifed in port 2
;
; Watchdog
;
; port 6 output: in theory, any read or write will reset the watchdog.
;                However, the 8bitworkshop emulator only resets on writes.


; #############################
; #############################
; ###                       ###
; ###                       ###
; ###     MEMORY LAYOUT     ###
; ###                       ###
; ###                       ###
; #############################
; #############################

STACK_TOP	.equ	$2400
FRAME_BUFFER	.equ	$2400


; ####################
; ####################
; ###              ###
; ###              ###
; ###     CODE     ###
; ###              ###
; ###              ###
; ####################
; ####################

; ############
; ##        ##
; ##  INIT  ##
; ##        ##
; ############

	.8080			; Beware: Space Invaders uses a true 8080
				; but zmac and 8bitworkshop support full Z80
				; such that there's a risk that this code
				; might not work on actual hardware (or on
				; a strict 8080 emulator)
                                ; This also means that the few areas

	.org	0		; Execution starts at address 0

	DI			; Let's not use interrupts (yet)

	LXI	SP,STACK_TOP	; Set up the stack at the top of the user RAM

; ############
; ##        ##
; ##  TEST  ##
; ##        ##
; ############

	CALL	bg		; Fill background

	MVI	B,20
	MVI	C,203
	MVI	D,20
	MVI	E,89
	CALL	ui_window

	MVI	B,60
	MVI	C,160
	CALL	one_char

forever:
	OUT	6		; Tickle watchdog
	JMP	forever		; Main loop

; ###########################
; ###########################
; ###                     ###
; ###                     ###
; ###     UI ROUTINES     ###
; ###                     ###
; ###                     ###
; ###########################
; ###########################


ui_window:
	PUSH	B
	PUSH	D
	CALL	rblack
	POP	D
	POP	B
	PUSH	B
	PUSH	D
	INR	B
	DCR	C
	DCR	C
	INR	D
	MOV	A,D
	ADI	8
	MOV	E,A
	CALL	rwhite
	POP	D
	POP	B
	PUSH	B
	PUSH	D
	INR	B
	MOV	A,C
	SBI	12
	MOV	C,A
	MOV	A,D
	ADI	11
	MOV	D,A
	MOV	A,E
	SBI	12
	MOV	E,A
	CALL	rwhite
	POP	D
	POP	B
	PUSH	B
	PUSH	D
	MOV	A,C
	SBI	2
	MOV	C,A
	SBI	8
	MOV	B,A
	MOV	A,E
	SBI	2
	MOV	E,A
	SBI	8
	MOV	D,A
	CALL	rwhite
	POP	D
	POP	B
	PUSH	B
	PUSH	D
	MOV	A,C
	SBI	2
	MOV	C,A
	SBI	8
	MOV	B,A
	MOV	A,D
	ADI	11
	MOV	D,A
	MOV	A,E
	SBI	12
	MOV	E,A
	CALL	rwhite
	POP	D
	POP	B
	PUSH	B
	PUSH	D
	INR	B
	MOV	A,C
	SBI	12
	MOV	C,A
	MOV	A,E
	SBI	2
	MOV	E,A
	SBI	8
	MOV	D,A
	CALL	rwhite
	POP	D
	POP	B
	RET


; #################################
; #################################
; ###                           ###
; ###                           ###
; ###     GRAPHICS ROUTINES     ###
; ###                           ###
; ###                           ###
; #################################
; #################################


; ##########################
; ##                      ##
; ##  BACKGROUND STIPPLE  ##
; ##                      ##
; ##########################

; Inputs: none
; Outputs: none
; Modifies: BCHLFA

; Possible speed optimization: unroll loop slightly (e.g. 2x, 4x).

bg:
	MVI	C,224		; 224 columns per screen

	LXI	H,FRAME_BUFFER	; Start address of framebuffer
	MVI	A,$55		; Pattern
bgcol:

	MVI	B,32		; 32 bytes per column
bgbyte:
	MOV	M,A		; Write byte through HL
	INX	H		; Increment HL pointer
	DCR	B		; Decrement loop counter
	JNZ	bgbyte		; Loop

	CMA			; Flip pattern bits

	DCR	C		; Decrement loop counter
	JNZ	bgcol		; Loop

	RET


; #############################
; ##                         ##
; ##  HORIZONTAL LINE WHITE  ##
; ##                         ##
; #############################

; Inputs: B: xleft
;         C: xright
;         D: y
; Outputs: none
; Modifies: BCDEHLFA


hwhite:
; compute number of columns, store in E
	MOV	A,C
	SUB	B
	INR	A
	MOV	E,A	; E = C - B + 1

; address of the first column: HL = FRAME_BUFFER + B * 32
	MOV	L,B
	MVI	H,0
	DAD	H
	DAD	H
	DAD	H
	DAD	H
	DAD	H
	LXI	B,FRAME_BUFFER
	DAD	B

; address of first pixel: HL += (255 - D) >> 3
	MOV	A,D
	CMA
	RRC
	RRC
	RRC
	ANI	31
	ADD	L
	MOV	L,A

; pattern of pixels: A = $80 >> (D & 7)
	MOV	A,D
	ANI	7
	MOV	B,A
	MVI	A,10000000b
	JZ	hwshiftdone
hwshift:
	RRC
	DCR	B
	JNZ	hwshift
hwshiftdone:
	MOV	D,A

; write the actual pixels
	LXI	B,32
hwpixloop:
	MOV	A,D
	ORA	M
	MOV	M,A
	DAD	B
	DCR	E
	JNZ	hwpixloop

	RET

; #######################
; ##                   ##
; ##  RECTANGLE WHITE  ##
; ##                   ##
; #######################

; Inputs: B: xleft
;         C: xright
;         D: ytop
;         E: ybottom
; Outputs: none
; Modifies: DHLFA

rwhite:
	PUSH	B		; Save BC
	PUSH	D		; Save DE

	CALL	hwhite		; Draw one line

	POP	D		; Recover DE
	POP	B		; Recover BC

	MOV	A,D
	CMP	E		; Check if drawn last line
	RZ			; If yes, return

	INR	D		; Move to next line
        JMP	rwhite		; Continue

; #############################
; ##                         ##
; ##  HORIZONTAL LINE BLACK  ##
; ##                         ##
; #############################

; Inputs: B: xleft
;         C: xright
;         D: y
; Outputs: none
; Modifies: BCDEHLFA


hblack:
; compute number of columns, store in E
	MOV	A,C
	SUB	B
	INR	A
	MOV	E,A	; E = C - B + 1

; address of the first column: HL = FRAME_BUFFER + B * 32
	MOV	L,B
	MVI	H,0
	DAD	H
	DAD	H
	DAD	H
	DAD	H
	DAD	H
	LXI	B,FRAME_BUFFER
	DAD	B

; address of first pixel: HL += (255 - D) >> 3
	MOV	A,D
	CMA
	RRC
	RRC
	RRC
	ANI	31
	ADD	L
	MOV	L,A

; pattern of pixels: A = $80 >> (D & 7)
	MOV	A,D
	ANI	7
	MOV	B,A
	MVI	A,10000000b
	JZ	hbshiftdone
hbshift:
	RRC
	DCR	B
	JNZ	hbshift
hbshiftdone:
	CMA
	MOV	D,A

; write the actual pixels
	LXI	B,32
hbpixloop:
	MOV	A,D
	ANA	M
	MOV	M,A
	DAD	B
	DCR	E
	JNZ	hbpixloop

	RET

; #######################
; ##                   ##
; ##  RECTANGLE BLACK  ##
; ##                   ##
; #######################

; Inputs: B: xleft
;         C: xright
;         D: ytop
;         E: ybottom
; Outputs: none
; Modifies: DHLFA

rblack:
	PUSH	B		; Save BC
	PUSH	D		; Save DE

	CALL	hblack		; Draw one line

	POP	D		; Recover DE
	POP	B		; Recover BC

	MOV	A,D
	CMP	E		; Check if drawn last line
	RZ			; If yes, return

	INR	D		; Move to next line
        JMP	rblack		; Continue

; #####################
; ##                 ##
; ##  ONE CHARACTER  ##
; ##                 ##
; #####################

; Draws one character at the specified coordinates.
; Coordinates are the top-left corner of the character.
; Restrictions: no checks are performed on the inputs.

; Inputs: B: x
;         C: y
;         D:
;         E:
; Outputs: none
; Modifies: TBD

one_char:
	; A=? B=x C=y DE=? HL=?

	; Compute x * 32 by adding HL to itself 5 times.
	MOV	L,B	; 5
	MVI	H,0	; 7
	DAD	H	; 10
	DAD	H	; 10
	DAD	H	; 10
	DAD	H	; 10
	DAD	H	; 10

	; A=? B=x C=y DE=? HL=32 * x

	; Add framebuffer address
	MOV	A,H	; 5
	ADI	FRAME_BUFFER>>8	; 7
	MOV	H,A	; 5

	; Add y offset = (255 - y) / 8
	MOV	A,C	; 5
	CMA		; 4	- 
	RAR		; 4
	RAR		; 4
	RAR		; 4
	ANI	$1F	; 7
	ADD	L	; 4
	MOV	L,A	; 5

	XCHG

	LXI	H,font	; 10

	MVI	B,8
char_column:
	MOV	A,M
	STAX	D
	DCR	B
	RZ
	INX	H
	MOV	A,E
	ADI	32
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	JMP	char_column

	RET


; ####################
; ####################
; ###              ###
; ###              ###
; ###     DATA     ###
; ###              ###
; ###              ###
; ####################
; ####################

font:
	.defb	11111111b
	.defb	10000001b
	.defb	00000001b
	.defb	01110111b
	.defb	01110111b
	.defb	00000001b
	.defb	10000001b
	.defb	11111111b

	.defb	11111111b
	.defb	00000001b
	.defb	00000001b
	.defb	01101101b
	.defb	01101101b
	.defb	00000001b
	.defb	10010011b
	.defb	11111111b

	.defb	11111111b
	.defb	10000011b
	.defb	00000001b
	.defb	01111101b
	.defb	01111101b
	.defb	00111001b
	.defb	10111011b
	.defb	11111111b

	.defb	11111111b
	.defb	00000001b
	.defb	00000001b
	.defb	01111101b
	.defb	01111101b
	.defb	00000001b
	.defb	10000011b
	.defb	11111111b
; 345678901234567890123456789012345678901234567890123456789012345678901234567890
